<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://www.colmryan.org/theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://www.colmryan.org/theme/pygments/github.min.css">
  <link rel="stylesheet" type="text/css" href="http://www.colmryan.org/theme/font-awesome/css/font-awesome.min.css">


    <link href="http://www.colmryan.org/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Tomorrow Said Toad Atom">



  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />


<meta name="author" content="Colm Ryan" />
<meta name="description" content="I'm taken with using Python's relatively recent asycio module for real-time DSP. This isn't because it looks particularly efficient but because it looks very similar to how we do DSP on an FPGA. Of course we won't actually get the massive parallelism of a real FPGA ..." />
<meta name="keywords" content="">
<meta property="og:site_name" content="Tomorrow Said Toad"/>
<meta property="og:title" content="asyncio real-time signal processing"/>
<meta property="og:description" content="I'm taken with using Python's relatively recent asycio module for real-time DSP. This isn't because it looks particularly efficient but because it looks very similar to how we do DSP on an FPGA. Of course we won't actually get the massive parallelism of a real FPGA ..."/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://www.colmryan.org/drafts/asyncio-real-time-signal-processing.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2015-09-20 00:00:00-04:00"/>
<meta property="article:modified_time" content="2015-10-03 00:00:00-04:00"/>
<meta property="article:author" content="http://www.colmryan.org/author/colm-ryan.html">
<meta property="article:section" content="Python"/>
<meta property="og:image" content="">
  <title>Tomorrow Said Toad &ndash; asyncio real-time signal processing</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://www.colmryan.org">
        <img src="http://www.colmryan.org/theme/img/profile.png" alt="Tomorrow Said Toad" title="Tomorrow Said Toad">
      </a>
      <h1><a href="http://www.colmryan.org">Tomorrow Said Toad</a></h1>
<p>Today I will take life easy...</p>      <nav>
        <ul class="list">
          <li><a href="http://getpelican.com/" target="_blank">Pelican</a></li>
          <li><a href="http://python.org/" target="_blank">Python.org</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-github" href="http://github.com/caryan" target="_blank"><i class="fa fa-github"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>

<article>
  <header>
    <h1 id="asyncio-real-time-signal-processing">asyncio real-time signal processing</h1>
    <p>Posted on Sun 20 September 2015 in <a href="http://www.colmryan.org/category/python.html">Python</a></p>
  </header>
  <div>
    <p>I'm taken with using Python's relatively recent asycio module for real-time DSP.
This isn't because it looks particularly efficient but because it looks very
similar to how we do DSP on an FPGA. Of course we won't actually get the massive
parallelism of a real FPGA but by setting up all our coroutines at the start and
letting things go, the data will naturally flow through the processing chain and
handle back pressure without any particular intervention or scheduling by us.
This also allows us to tap into the the data stream at any point for addition
processing, plotting or saving.</p>
<p>In FPGA land we have all our DSP (FIR filtering, demodulating, decimating etc.)
as modules that takes streams of data (AXI streams) and every clock cycle
they'll process data with something like:</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span> <span class="k">and</span> <span class="n">data_vld</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span> <span class="k">then</span>
    <span class="n">process_data</span><span class="p">....</span>
<span class="k">end</span> <span class="k">if</span><span class="p">;</span>
</pre></div>


<p>All the modules are connected by FIFOs that allow the system to cross clock
domains and soak up back-pressure if the system is producing data faster than it
can be processed. Of course if the system is continually taking data faster than
processing we'll run into an issue but for short burst of data this works well
as the chains of FIFO's just absorb the pressure without any additional
thinking.</p>
<p>With Python's asyncio co-routines and Queues we should be able to setup
something very similar. Let's setup a simple class structure with
<code>DataProducer</code>'s,  <code>DataCrucher</code>'s, <code>DataPlotters</code>'s, and <code>DataWriters</code>.</p>
<p>A <code>DataProducer</code> is anything that produces data that can be consumed by
anything else.  At the start this may be an ADC but in a chain of filters each
element is a <code>DataCruncher</code> that also acts as a <code>DataProducer</code> for next
element in the chain.  Let's make a fake ADC that takes data up to a timeout
and then finishes.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DataProducer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">queue</span>

<span class="k">class</span> <span class="nc">ADC</span><span class="p">(</span><span class="n">DataProducer</span><span class="p">):</span>

        <span class="n">async</span> <span class="k">def</span> <span class="nf">take_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
            <span class="n">end_time</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
                <span class="n">timeStamp</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Acquired data and putting in queue&quot;</span><span class="p">)</span>
                <span class="n">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">end_time</span><span class="p">:</span>
                    <span class="n">shutdown</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>


<p>A <code>DataProducer</code> has a queue that it pushes data to.  The data will be
correctly routed by a <code>DataInterconnect</code> later. We define the <code>take_data</code>
method as an async co-routine using the new Python 3.5 syntax of <code>async def</code>.
Since the
<a href="https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue.put">Queue.put</a>
method is a coroutine we <code>await</code> on that (again using the the new syntax
instead of the old <code>yield from</code>).</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">DataCrucher</span>(<span class="n">DataProducer</span>):
    <span class="nb">pass</span>
</pre></div>


<p>In Python the FIFOs will be handled by
<a href="https://docs.python.org/3/library/asyncio-queue.html">asyncio.Queue</a></p>
  </div>
  <div class="tag-cloud">
    <p>
    </p>
  </div>
</article>

    <footer>
<p>
  &copy; Colm Ryan 2016 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>





<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Tomorrow Said Toad ",
  "url" : "http://www.colmryan.org",
  "image": "",
  "description": ""
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "asyncio real-time signal processing",
  "headline": "asyncio real-time signal processing",
  "datePublished": "2015-09-20 00:00:00-04:00",
  "dateModified": "2015-10-03 00:00:00-04:00",
  "author": {
    "@type": "Person",
    "name": "Colm Ryan",
    "url": "http://www.colmryan.org/author/colm-ryan.html"
  },
  "image": "{{ SITEURL }}/{{ THEME_STATIC_DIR }}/img/profile.png",
  "url": "http://www.colmryan.org/drafts/asyncio-real-time-signal-processing.html",
  "description": "I'm taken with using Python's relatively recent asycio module for real-time DSP. This isn't because it looks particularly efficient but because it looks very similar to how we do DSP on an FPGA. Of course we won't actually get the massive parallelism of a real FPGA ..."
}
</script></body>
</html>